{"version":3,"sources":["utilities/myLibrary.js","components/CodeText.js","assets/logo.png","components/Operand.js","components/Operands.js","components/Operator.js","components/Operations.js","components/Explanation.js","components/Visualization.js","components/App.js","serviceWorker.js","reportWebVitals.js","index.js"],"names":["constructDataListTable","aSimdDescriptionFile","intrinsic","map","e","parameter","hasOwnProperty","objectDescription","line1","_rettype","_name","Array","isArray","flatMap","i","length","_type","_varname","join","line2","header","instruction","_form","CPUID","line3","description","line4","operation","replaceAll","computeOperandsAndresultElt","obj","name","regTypeNumber","arrayOfMinimunSizeInDescription","match","sizeOfScalarField","Math","min","maxSize","result","retType","retTypeNumber","size","operands","varnames","types","forEach","element","k","split","operandNumber","operand","operandSize","readLinkingIndexMsg","aLinkingIndex","Msge","indexOfactive","findIndex","slice","flat","sort","a","b","reduce","pre","cur","myDataListTab","myLib","simdFunction","options","value","CodeText","acc","indexOf","find","ex","props","handleOnchange","this","className","htmlFor","type","id","autoComplete","aria-label","list","defaultValue","onChange","Component","Operand","prevProps","prevState","snapshot","accumulator","currentValue","rank","xOperand0","xPrefixWidth","gOperand","o","j","toLowerCase","onClick","evt","handleOperandClick","y","x","width","height","dy","dx","rectOperandHeight","dominantBaseline","textAnchor","String","fromCharCode","varName","varType","Operands","currentInstruction","currentInstructionMember","transform","translation","operators","Operator","rectOprHeight","xOpr0","gOperator","handleOperatorClick","Operations","version","xmlns","xmlnsXlink","linkingIndex","Explanation","currentResult","butonMsg","form","handlesimdButtonClick","operandsAndResults","constInitialLinkingIndexInstruction","instructionName","Visualization","currentInstructionR","currentTarget","includes","number","textContent","indexR","state","setState","anArray","anIndex","currentInstructionO","indexOfOperand","indexOfResult","some","currentOperator","g","ov","alik2","maxRank","max","operator","fill","bind","linkingIndexTable","newLinkinIndexObject","indexOfPrevLinkingIndex","Fragment","styled","div","App","target","isLocalhost","Boolean","window","location","hostname","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","onUpdate","onSuccess","catch","error","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","basename","process","exact","path","component","document","getElementById","URL","origin","addEventListener","fetch","response","status","headers","get","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.186b4a70.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport * as _ from \"lodash\";\r\n// import 'array-flat-polyfill';\r\n// import 'underscore';\r\n\r\nexport function instructionsByRegisterBySteps(arrayOfObject) {//objects are quatriples {id, intrinsic, line, registers}\r\n  var newArray = []\r\n  arrayOfObject.map(function (anIntrObj) {\r\n    for (let i = 0; i < anIntrObj.registers.length; i++) {\r\n      var obj = { register: \"\", instructions: [] }\r\n      let objInstr = { id: anIntrObj.id, intrinsic: anIntrObj.intrinsic, line: anIntrObj.line, idr: anIntrObj.registers.length - i }\r\n      let register = anIntrObj.registers[i]\r\n      obj.register = register\r\n      obj.instructions.push(objInstr)\r\n      if (newArray.find(x => x.register == obj.register)) {\r\n        if (!(newArray.find(x => x.register == obj.register).instructions.find(x => x.id == objInstr.id && x.intrinsic == objInstr.intrinsic && x.idr == objInstr.idr))) {\r\n          newArray.find(x => x.register == obj.register).instructions.push(objInstr)\r\n        }\r\n      }\r\n      else {\r\n        newArray.push(obj)\r\n      }\r\n    }\r\n  })\r\n  let sorted = newArray.sort((a, b) => (a.register > b.register ? 1 : a.register < b.register ? -1 : 0))\r\n  return sorted\r\n}\r\n\r\n\r\nexport function searchInstruction(id, idr, tab) {//this function extracts from an array of objects (tab) { register:, instructions:} an object in the form {instruction:, register: } corresponding to the criteria passed to it as a parameter (id, idr,tab). the property instructions is an array of triples\r\n  var varInstruction = null\r\n  tab.find(function (obj) {\r\n    return obj.instructions.find(function (instruction) {\r\n      varInstruction = (instruction.id == id && instruction.idr == idr) ? { register: obj.register, instruction: instruction } : null\r\n      return instruction.id == id && instruction.idr == idr\r\n    })\r\n  })\r\n  return varInstruction\r\n}\r\n\r\nexport function displayWindow(aWindow) {// aWindow is an object {id:, idr:, tab}. This function construct an object {id:, idr:, name:, register:} based on aWindow\r\n  var objectTodisplay = {}, currentWindow = null;\r\n  if (searchInstruction(aWindow.id, aWindow.idr, aWindow.tab)) {\r\n    currentWindow = searchInstruction(aWindow.id, aWindow.idr, aWindow.tab);\r\n    objectTodisplay.id = currentWindow.instruction.id;\r\n    objectTodisplay.idr = currentWindow.instruction.idr;\r\n    objectTodisplay.name = currentWindow.instruction.intrinsic;\r\n    objectTodisplay.register = currentWindow.register;\r\n  }\r\n  return objectTodisplay\r\n}\r\n\r\nexport function advanceWindow(aWindow) {// This function makes it possible to go from one step in the execution of an instruction to the next step, or from one instruction to the next when all the steps of the current instruction are exhausted. At the last step of the last instruction of the program been retrieved, it starts again and returns the first step of the first instruction of the program been retrieved. The continuous application of this function therefore generates cyclical data.\r\n  return searchInstruction(aWindow.id, aWindow.idr + 1, aWindow.tab) ? { id: aWindow.id, idr: aWindow.idr + 1, tab: aWindow.tab } : (searchInstruction(aWindow.id + 1, 1, aWindow.tab) ? { id: aWindow.id + 1, idr: 1, tab: aWindow.tab } : { id: 0, idr: 1, tab: aWindow.tab })\r\n}\r\nexport function message(aWindow) {//this function generate a message in the form of and object {head:, body}. the body contains a html element containing a text to display. The text is construct based on aWindow. the property head contains the name of the correspondant register.\r\n  const styleText = { color: \"#86DE74\" }//style of the text to display, except the name of the instruction (which is displaye in the same style as the id and idr)\r\n  const styleId = { color: \"#FF7DE9\" }\r\n  var messageContent = displayWindow(aWindow)//Below we identify the paragraph (tag p) with the id of aWindow messageContent.id as we will use this id to set the same color for the paragraph having the same id\r\n  var message = { head: messageContent.register, body: <p className={messageContent.id} ><span style={styleText}>instruction:</span> <span style={styleId}>{messageContent.id}</span><br /><span style={styleText}>step:</span> <span style={styleId}>{messageContent.idr}</span><br /><span style={styleId}>{messageContent.name}</span></p> }\r\n  return message\r\n}\r\n\r\nexport function pickStep(instNumber, arrayOfInstructions) {//takes an array of instructions and an instruction number, then returns an array consisting of the steps of the instruction whose number was given.here an instruction is a triple {id:, name:, idr:, line}\r\n  return arrayOfInstructions.reduce((acc, curr) => (curr.id == instNumber) ? [curr.idr, ...acc] : acc, []);\r\n}\r\n\r\nexport function extractStepRegAtInst(aRegister, anArrayOfRegisters, instNumber) {// extract from an array of register the steps of an instruction executed on this register.this instruction is identified by its id. returns null if no step of this instruction is executed on this register.\r\n  return anArrayOfRegisters.find(e => e.register == aRegister) ? pickStep(instNumber, anArrayOfRegisters.find(e => e.register == aRegister).instructions) : null\r\n}\r\n\r\nexport function buildMatrixRegInt(anArrayOfRegisters, anArrayOfInstructions) {\r\n  let augMentArrayOfReg = [{ register: \"NAME\" }, ...anArrayOfRegisters]\r\n  let matrix = augMentArrayOfReg.map(e => new Array(anArrayOfInstructions.length + 1).fill(e.register))\r\n  matrix = matrix.map(r => (r[0] == \"NAME\") ? (r.map((c, i) => (i == 0) ? r[0] : { name: \"\" + anArrayOfInstructions[i - 1].intrinsic, line: anArrayOfInstructions[i - 1].line })) : (r.map((c, i) => (i == 0) ? r[0] : extractStepRegAtInst(c, anArrayOfRegisters, i - 1))))\r\n  return matrix[0].map((x, i) => matrix.map(x => x[i])) //this is to transpose\r\n}\r\n\r\nexport function searchStep(lineIndex, columnIndex, aMatrix) {\r\n  return lineIndex > 0 && columnIndex >= 0 && lineIndex < aMatrix.length && columnIndex < aMatrix[0].length && (aMatrix[lineIndex][columnIndex].length > 0 || (aMatrix[lineIndex][columnIndex] !== null && !Array.isArray(aMatrix[lineIndex][columnIndex])))\r\n}\r\n\r\nexport function advanceMatrixWindow(lineIndex, columnIndex, aMatrix) {//Advance the window to the next step of an instruction or until the next instruction.\r\n  return {\r\n    value: searchStep(lineIndex, columnIndex + 1, aMatrix) ? aMatrix[lineIndex][columnIndex + 1] :\r\n      ((lineIndex >= aMatrix.length - 1 && columnIndex >= aMatrix[0].length - 1 && searchStep(1, 0, aMatrix)) ? aMatrix[1][0] :\r\n        (((lineIndex >= aMatrix.length - 1 && columnIndex >= aMatrix[0].length - 1) || (lineIndex <= 0 || columnIndex < 0)) ? advanceMatrixWindow(1, 0, aMatrix).value :\r\n          ((columnIndex >= aMatrix[0].length - 1 && searchStep(lineIndex + 1, 0, aMatrix)) ? aMatrix[lineIndex + 1][0] :\r\n            ((columnIndex >= aMatrix[0].length - 1 && lineIndex < aMatrix.length - 1) ? advanceMatrixWindow(lineIndex + 1, 0, aMatrix).value :\r\n              ((lineIndex >= aMatrix.length - 1 && searchStep(aMatrix.length - 1, columnIndex + 1, aMatrix)) ? aMatrix[aMatrix.length - 1][columnIndex + 1] :\r\n                (advanceMatrixWindow(lineIndex, columnIndex + 1, aMatrix).value)))))),\r\n    indexes: searchStep(lineIndex, columnIndex + 1, aMatrix) ? [lineIndex, columnIndex + 1] :\r\n      ((lineIndex >= aMatrix.length - 1 && columnIndex >= aMatrix[0].length - 1 && searchStep(1, 0, aMatrix)) ? [1, 0] :\r\n        (((lineIndex >= aMatrix.length - 1 && columnIndex >= aMatrix[0].length - 1) || (lineIndex <= 0 || columnIndex < 0)) ? advanceMatrixWindow(1, 0, aMatrix).indexes :\r\n          ((columnIndex >= aMatrix[0].length - 1 && searchStep(lineIndex + 1, 0, aMatrix)) ? [lineIndex + 1, 0] :\r\n            ((columnIndex >= aMatrix[0].length - 1 && lineIndex < aMatrix.length - 1) ? advanceMatrixWindow(lineIndex + 1, 0, aMatrix).indexes :\r\n              ((lineIndex >= aMatrix.length - 1 && searchStep(aMatrix.length - 1, columnIndex + 1, aMatrix)) ? [aMatrix.length - 1, columnIndex + 1] :\r\n                (advanceMatrixWindow(lineIndex, columnIndex + 1, aMatrix).indexes))))))\r\n  }\r\n\r\n}\r\n\r\n\r\nexport function retrievePosition(aPosition, aMatrix) {\r\n  if (aPosition.rank == 0) {//we are at the first column (index 0)\r\n    return <th className=\"intrinsicName\" rowSpan=\"3\" scope=\"rowgroup\"><span className=\"intrinsicName\">{aMatrix[aPosition.line][aPosition.column].name.toUpperCase()}</span></th>\r\n  }\r\n  else\r\n    if (aMatrix[aPosition.line][aPosition.column].length == 1) {\r\n      if (aPosition.rank == buildNonNulPositionsLine(aPosition.line, aMatrix).length - 1) {\r\n        return <React.Fragment><td ><span className=\"empty\"></span>a</td><td ><span className=\"empty\"></span>a</td><td className=\"out\"><span className=\"out\">&#x21D9;</span></td></React.Fragment>\r\n      }\r\n      else {\r\n        return <React.Fragment><td className=\"in\"><span className=\"in\">&#x21D7;</span></td><td ><span className=\"empty\"></span></td><td ><span className=\"empty\"></span></td></React.Fragment>\r\n      }\r\n    }\r\n    else\r\n      if (aMatrix[aPosition.line][aPosition.column].length == 2) {\r\n        if (aPosition.rank == buildPosition(aPosition.line, aPosition.column, aMatrix)[0].rank) {\r\n          return <React.Fragment><td className=\"in\"><span className=\"in\">&#x21D7;</span></td><td ><span className=\"empty\"></span></td><td ><span className=\"empty\"></span></td></React.Fragment>\r\n        }\r\n        else {\r\n          return <React.Fragment><td className=\"in\"><span className=\"in\">&#x21D7;</span></td><td ><span className=\"empty\"></span></td><td className=\"out\"><span className=\"out\">&#x21D9;</span></td></React.Fragment>\r\n        }\r\n      }\r\n}\r\n\r\nexport function preRetrieveLinePosition(aPosition, aMatrix) {//this function retrieve and return the ligne corresponding to the aPosition.line each time it is called, as aPosition move foward\r\n  return aMatrix[aPosition.line].map((x, j) => j == 0 ? x : retrieveIndexPositionLine(aPosition.line, j, aPosition, aMatrix))//in, out or inout is put where necessary\r\n}\r\n\r\nexport function initializeLinesMatrix(aLine, aMatrix) {\r\n  var ligne1 = <th rowSpan=\"3\" scope=\"rowgroup\" className=\"empty\"></th>, ligne2 = null, ligne3 = null;\r\n  for (let j = 1; j < aMatrix[aLine].length; j++) {\r\n    ligne1 = <React.Fragment>{ligne1}<td className=\"empty\"></td></React.Fragment>\r\n    ligne2 = <React.Fragment>{ligne2}<td className=\"empty\"></td></React.Fragment>\r\n    ligne3 = <React.Fragment>{ligne3}<td className=\"empty\"></td></React.Fragment>\r\n  }\r\n  return <tbody><tr>{ligne1}</tr><tr>{ligne2}</tr><tr>{ligne3}</tr></tbody>\r\n}\r\n\r\nexport function initializeFirstLineMatrix(firstLine, aMatrix) {//should have call this initializeFirstLigneMatrix\r\n  var ligne1 = <th rowSpan=\"3\" scope=\"rowgroup\" className=\"intrinsicName\">{aMatrix[firstLine][0].name.toUpperCase()}</th>, ligne2 = null, ligne3 = null;\r\n  for (let j = 1; j < aMatrix[firstLine].length; j++) {\r\n    ligne1 = <React.Fragment>{ligne1}<td className=\"empty\"></td></React.Fragment>\r\n    ligne2 = <React.Fragment>{ligne2}<td className=\"empty\"></td></React.Fragment>\r\n    ligne3 = <React.Fragment>{ligne3}<td className=\"empty\"></td></React.Fragment>\r\n  }\r\n  return <tbody><tr>{ligne1}</tr><tr>{ligne2}</tr><tr>{ligne3}</tr></tbody>\r\n}\r\n\r\nexport function retrieveIndexPositionLine(aLine, aColumn, aPosition, aMatrix) {//all the positions before aPosition (those wich position are <= aPosition.rank) are retrieve\r\n  var statePos = null\r\n  if (aLine == aPosition.line) {//this condition could have been left\r\n    let indexPosition = buildPosition(aLine, aColumn, aMatrix)\r\n    if (indexPosition) {\r\n      let l = indexPosition.length\r\n      switch (l) {\r\n        case 1: if (indexPosition[0].rank == buildNonNulPositionsLine(aPosition.line, aMatrix).length - 1 && indexPosition[0].rank <= aPosition.rank) {//rank are ordered and if indexPosition[0] is the last position of the line, it is an out position\r\n          statePos = \"out\"// is the last step, the last position\r\n        }\r\n        else\r\n          if (indexPosition[0].rank <= aPosition.rank) {//indexPosition[0] isn't the last position of the line, it is an in\r\n            statePos = \"in\" + indexPosition[0].rank//add indexPosition[0].rank to intentify the step being executed (the position reach by the program execution or more precisely the flow of the program)\r\n          }\r\n          break;\r\n        case 2: if (indexPosition[1].rank <= aPosition.rank) {\r\n          statePos = \"inout\" + indexPosition[0].rank// the last step but they are two steps in this i,j index (two positions) (they are two steps which means the instruction has two steps on the corresponding register, necessarily an in and an out) and it is important to know the rank (number) of the first step (the last being an out=the last step of the line)\r\n        }//inout is  to remind that they are two positions at this i, j index it could have been out if not\r\n        else\r\n          if (indexPosition[0].rank <= aPosition.rank) {\r\n            statePos = \"in\" + indexPosition[0].rank// this rank indicate the position or the number of the this step\r\n          }\r\n          break;\r\n\r\n      }\r\n    }\r\n\r\n\r\n  }\r\n  return statePos\r\n}\r\n\r\nexport function buildPosition(indexLine, indexColumn, aMatrix) {\r\n  let obj = {}\r\n  let positionsLineCol = (searchStep(indexLine, indexColumn, aMatrix) && Array.isArray(aMatrix[indexLine][indexColumn])) ? aMatrix[indexLine][indexColumn].map(e => obj = { line: indexLine, column: indexColumn, rank: e, codeLine: aMatrix[indexLine][0].line }).sort((a, b) => a.rank - b.rank) ://e represent the step of instruction, step 1, 2, etc.(step is associate with the register)\r\n    (searchStep(indexLine, indexColumn, aMatrix) ? new Array(obj = { line: indexLine, column: indexColumn, rank: 0, codeLine: aMatrix[indexLine][0].line }) : null)\r\n  return positionsLineCol\r\n}\r\n\r\n\r\n\r\nexport function buildNonNulPositionsLine(indexLine, aMatrix) {\r\n  let positionsLine = aMatrix[indexLine].map((e, i) => searchStep(indexLine, i, aMatrix) ? buildPosition(indexLine, i, aMatrix) : null).flat().filter(e => e).sort((a, b) => a.rank - b.rank)\r\n  return positionsLine\r\n}\r\n\r\n\r\nexport function buildNonNulPositions(aMatrix) {\r\n  return aMatrix.map((e, i) => buildNonNulPositionsLine(i, aMatrix).length > 0 ? buildNonNulPositionsLine(i, aMatrix) : null)\r\n}\r\n\r\n\r\nexport function advancePosition(aPosition, aMatrix) {\r\n  return buildNonNulPositionsLine(aPosition.line, aMatrix).find(e => e.rank > aPosition.rank) ? buildNonNulPositionsLine(aPosition.line, aMatrix).find(e => e.rank > aPosition.rank) :\r\n    buildNonNulPositionsLine(advanceMatrixWindow(buildNonNulPositionsLine(aPosition.line, aMatrix).find((pos, i, t) => !t.some(x => x.column > pos.column)).line, buildNonNulPositionsLine(aPosition.line, aMatrix).find((pos, i, t) => !t.some(x => x.column > pos.column)).column, aMatrix).indexes[0], aMatrix)[0]\r\n}\r\n\r\nexport function advanceLinePosition(aPosition, aMatrix) {\r\n  return (aPosition.line === advancePosition(aPosition, aMatrix).line && aPosition.rank !== null) ? advancePosition(aPosition, aMatrix) :\r\n    (aPosition.rank !== null ? { line: aPosition.line, column: aMatrix[0].length - 1, rank: null, codeLine: aPosition.codeLine } : buildNonNulPositionsLine(advanceMatrixWindow(aPosition.line, aPosition.column, aMatrix).indexes[0], aMatrix)[0])\r\n}\r\nexport function renameReg(aRegister) {\r\n  return aRegister.length == 4 ? aRegister[0].toUpperCase() + aRegister[3] : (aRegister[0] + \"M\").toUpperCase()\r\n}\r\n\r\n\r\nexport function renameRegister(aMatrix) {\r\n  return aMatrix.map((e, i) => i == 0 ? e.map((x, j) => j == 0 ? x : renameReg(x)) : e)\r\n}\r\nexport function removePrefix(linesPrefix, aMatrix) {\r\n  return aMatrix.map((e, i) => i == 0 ? e : e.map((x, j) => j == 0 && findPrefix(linesPrefix, x.name.toUpperCase()) ? { name: x.name.slice(findPrefix(linesPrefix, x.name.toUpperCase()).length), line: x.line } : x))\r\n}\r\n\r\nexport function findPrefix(linesPrefix, anInstruction) {\r\n  return linesPrefix.find((currentPre, indexPre, currentTa) => anInstruction.toUpperCase().slice(0, currentPre.length).match(currentPre.toUpperCase()) && !(currentTa.find(e => anInstruction.toUpperCase().slice(0, e.length).match(e.toUpperCase())).length > currentPre.length))\r\n}\r\n\r\nexport function removeSuffix(linesSuffix, aMatrix) {\r\n  return aMatrix.map((e, i) => i == 0 ? e : e.map((x, j) => j == 0 && findSuffix(linesSuffix, x.name.toUpperCase()) ? { name: x.name.slice(0, x.name.length - findSuffix(linesSuffix, x.name.toUpperCase()).length), line: x.line } : x))\r\n}\r\n\r\nexport function findSuffix(linesSuffix, anInstruction) {\r\n  return linesSuffix.find((currentPre, indexPre, currentTa) => anInstruction.toUpperCase().slice(anInstruction.length - currentPre.length).match(currentPre.toUpperCase()) && !(currentTa.find(e => anInstruction.toUpperCase().slice(anInstruction.length - e.length).match(e.toUpperCase())).length > currentPre.length))\r\n}\r\nexport function consPath(aPosition, aMatrix) {\r\n  return (forwardPathPosition(aPosition, aMatrix).concat(backwardPathPosition(aPosition, aMatrix))).sort((a, b) => compare(a, b))\r\n}\r\n\r\nexport function nextPositions(aPosition, aMatrix) {\r\n  var pathNextpos = []\r\n  if (aPosition.rank > 0) {\r\n    var forbidenColumn = 0\r\n    pathNextpos = [aPosition, ...pathNextpos]\r\n    let lastPositionLine = buildNonNulPositionsLine(aPosition.line, aMatrix)[buildNonNulPositionsLine(aPosition.line, aMatrix).length - 1]\r\n    if (aPosition.rank < lastPositionLine.rank) {// the last position is always the successor of all the position of the same line\r\n      pathNextpos = [lastPositionLine, ...pathNextpos]\r\n      forbidenColumn = lastPositionLine.column // the next position can't be on the same column after an out position (can't be skiped)\r\n    }\r\n    for (let i = aPosition.line; i < aMatrix.length; i++) {\r\n      let positionsLine = buildNonNulPositionsLine(i, aMatrix)\r\n      let posNext = positionsLine.find(e => e.column != forbidenColumn && e.column == aPosition.column && e.line != aPosition.line && !pathNextpos.find(x => _.isEqual(x, e)))\r\n      if (posNext) {\r\n        pathNextpos = posNext.rank < positionsLine[positionsLine.length - 1].rank ? [posNext, ...pathNextpos] : pathNextpos\r\n        break\r\n      }\r\n    }\r\n  }\r\n  return pathNextpos.sort((a, b) => compare(a, b))\r\n}\r\n\r\n\r\nexport function previousPositions(aPosition, aMatrix) {\r\n  var pathNextpos = []\r\n  if (aPosition.rank > 0) {\r\n    var authorizedColumn = aPosition.column // the previous position if not on the same line (wich is always the case for an out position) is always on the same column as the position\r\n    pathNextpos = [aPosition, ...pathNextpos]\r\n    let lastPositionLine = buildNonNulPositionsLine(aPosition.line, aMatrix)//[buildNonNulPositionsLine(aPosition.line, aMatrix).length-1]\r\n    if (aPosition.rank == lastPositionLine[lastPositionLine.length - 1].rank) {//  all the positions of the same line are always the predecessor of the out position\r\n      pathNextpos = [...lastPositionLine.filter(e => !pathNextpos.find(x => _.isEqual(x, e))), ...pathNextpos].filter(e => e.rank != 0)\r\n    }\r\n    else {\r\n      for (let i = aPosition.line; i > 0; i--) {\r\n        let positionsLine = buildNonNulPositionsLine(i, aMatrix)\r\n        let posNext = positionsLine.find(e => e.column == authorizedColumn && e.line != aPosition.line && !pathNextpos.find(x => _.isEqual(x, e)))\r\n        if (posNext) {\r\n          pathNextpos = positionsLine[positionsLine.length - 1].column == authorizedColumn ? [positionsLine[positionsLine.length - 1], ...pathNextpos] : [posNext, ...pathNextpos]//if the out position is in the same column it is the which one picked\r\n          break\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n  return pathNextpos.sort((a, b) => compare(a, b)).reverse()\r\n}\r\n\r\n\r\n\r\n\r\nexport function matrixPath(aMatrix) {\r\n  return aMatrix.map((x, i) => i == 0 ? [] : x.map((y, j) => j == 0 ? [] : (searchStep(i, j, aMatrix) ? buildPosition(i, j, aMatrix).map(e => nextPositions(e, aMatrix)) : [])))\r\n}\r\n\r\n\r\nexport function forwardPathPosition(aPosition, aMatrix) {\r\n  var forwardPathOfPosition = nextPositions(aPosition, aMatrix)\r\n  let level = 1\r\n  while (level < aMatrix.length) {\r\n    //forwardPathOfPosition=forwardPathOfPosition.map((e, i,t)=>nextPositions(e, aMatrix)).flat()\r\n    forwardPathOfPosition = forwardPathOfPosition.concat(forwardPathOfPosition.map((e, i, t) => nextPositions(e, aMatrix).filter(x => !t.find(y => y.rank == x.rank && y.column == x.column && y.line == x.line && y.codeLine == x.codeLine))).flat())\r\n    level++\r\n  }\r\n  return forwardPathOfPosition.sort((a, b) => compare(a, b))\r\n}\r\n/*function comptuteNextPositionsTab(tabOfPositions){\r\n  return tabOfPositions.length==1||!Array.isArray(tabOfPositions)?[tabOfPositions].flat():tabOfPositions.map(e=>comptuteNextPositionsTab(e))\r\n}*/\r\n\r\nexport function backwardPathPosition(aPosition, aMatrix) {\r\n  var backwardPathOfPosition = []\r\n  for (let i = 1; i < aPosition.line; i++) {\r\n    let positionsLine = buildNonNulPositionsLine(i, aMatrix)\r\n    for (let j = 0; j < positionsLine.length; j++) {\r\n      let forwardPathOfPositionj = forwardPathPosition(positionsLine[j], aMatrix)\r\n      backwardPathOfPosition = forwardPathOfPositionj.some(x => x.rank == aPosition.rank && x.column == aPosition.column && x.line == aPosition.line && x.codeLine == aPosition.codeLine) ? backwardPathOfPosition.concat(positionsLine[j]) : backwardPathOfPosition\r\n    }\r\n  }\r\n  let positionsLine = buildNonNulPositionsLine(aPosition.line, aMatrix)\r\n  for (let j = 0; j < aPosition.rank; j++) {\r\n    let forwardPathOfPositionj = forwardPathPosition(positionsLine[j], aMatrix)\r\n    backwardPathOfPosition = forwardPathOfPositionj.some(x => x.rank == aPosition.rank && x.column == aPosition.column && x.line == aPosition.line && x.codeLine == aPosition.codeLine) ? backwardPathOfPosition.concat(positionsLine[j]) : backwardPathOfPosition\r\n  }\r\n  return backwardPathOfPosition.sort((a, b) => compare(a, b))\r\n}\r\n\r\nexport function extractPositionFromId(aGivenId) {\r\n  let positionPropertiesArray = aGivenId.split(/[lcrz]/)\r\n  return { line: parseInt(positionPropertiesArray[1]), column: parseInt(positionPropertiesArray[2]), rank: parseInt(positionPropertiesArray[3]), codeLine: parseInt(positionPropertiesArray[4]) }\r\n}\r\n\r\nexport function maxPosition(aMatrix) {\r\n  let pos = buildNonNulPositionsLine(aMatrix.length - 1, aMatrix)[buildNonNulPositionsLine(aMatrix.length - 1, aMatrix).length - 1]\r\n  return pos\r\n}\r\n\r\nexport function minFreePosition(aListOfCurrentPosition) {\r\n  let anArray = aListOfCurrentPosition.map(e => e.idPosition)\r\n  anArray = anArray.map(e => parseInt(e, 10))\r\n  anArray = anArray.sort((a, b) => a - b)\r\n  let freePos = null\r\n  let l = anArray.length\r\n  switch (l) {\r\n    case 0: freePos = 1\r\n      break\r\n    case 1: if (anArray[0] != 1) {\r\n      freePos = 1\r\n    }\r\n    else {\r\n      freePos = 2\r\n    }\r\n      break\r\n    default: {\r\n      if (anArray[0] != 1) {\r\n        freePos = 1\r\n      }\r\n      else {\r\n        for (let i = 1; i < l; i++) {\r\n          if (anArray[i] - anArray[i - 1] > 1) {\r\n            freePos = anArray[i - 1] + 1\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  freePos = freePos ? freePos : l + 1\r\n  return freePos\r\n}\r\n\r\nexport function updateArrayOfCurrentPositions(anArrayOfCurrentPositions, idOfEventElt, aMatrix) {\r\n  let thisPosition = extractPositionFromId(idOfEventElt)//; console.log(\"nexposition\",  nextPositions(thisPosition, aMatrix), \"previous\", previousPositions(thisPosition, aMatrix))\r\n  let eltId = anArrayOfCurrentPositions.find(e => e.anElementId == idOfEventElt) //[...aListOfCurrentPosition, {aPosition:pathElt[0], anElementId:idOfEventElt}]\r\n  if (!eltId) {\r\n    let pathElt = consPath(extractPositionFromId(idOfEventElt), aMatrix)\r\n    let pathEltDown = forwardPathPosition(extractPositionFromId(idOfEventElt), aMatrix)\r\n    let pathEltUp = backwardPathPosition(extractPositionFromId(idOfEventElt), aMatrix).concat(thisPosition)\r\n    let positionsOfThisLine = buildNonNulPositionsLine(pathElt[0].line, aMatrix).filter(e => e.rank >= 1)\r\n    let positionsOfThisLineUp = buildNonNulPositionsLine(pathEltUp[0].line, aMatrix).filter(e => e.rank >= 1)\r\n    let positionsOfThisLineDown = buildNonNulPositionsLine(pathEltDown[0].line, aMatrix).filter(e => e.rank >= 1)\r\n    let restrictPositions = linePosition(pathElt, pathElt[0], aMatrix).filter(e => !_.isEqual(e, thisPosition)).length == 0 ? [positionsOfThisLine[positionsOfThisLine.length - 1]] : linePosition(pathElt, pathElt[0], aMatrix).filter(e => !_.isEqual(e, thisPosition))\r\n    let restrictPositionsup = linePosition(pathEltUp, pathEltUp[0], aMatrix).filter(e => !_.isEqual(e, thisPosition)).length == 0 ? [positionsOfThisLineUp[positionsOfThisLineUp.length - 1]] : linePosition(pathEltUp, pathEltUp[0], aMatrix).filter(e => !_.isEqual(e, thisPosition))\r\n    let restrictPositionsDown = linePosition(pathEltDown, pathEltDown[0], aMatrix).filter(e => !_.isEqual(e, thisPosition)).length == 0 ? [positionsOfThisLineDown[positionsOfThisLineDown.length - 1]] : linePosition(pathEltDown, pathEltDown[0], aMatrix).filter(e => !_.isEqual(e, thisPosition))\r\n    anArrayOfCurrentPositions = [...anArrayOfCurrentPositions, {\r\n      aCurrentPosition: restrictPositions, aCurrentPositionUp: previousPositions(thisPosition, aMatrix), aCurrentPositionDown: nextPositions(thisPosition, aMatrix), anElementId: idOfEventElt, idPosition: minFreePosition(anArrayOfCurrentPositions),\r\n      listOfPath: pathElt, listOfPathUp: pathEltUp, listOfPathDown: pathEltDown, linkedPositionsUp: [thisPosition], linkedPositionsDown: [thisPosition]\r\n    }]\r\n  }\r\n  else {\r\n    anArrayOfCurrentPositions.splice(anArrayOfCurrentPositions.indexOf(eltId), 1)\r\n  }\r\n  return anArrayOfCurrentPositions\r\n}\r\n\r\n\r\nexport function linePosition(aPath, aPosition, aMatrix) {\r\n  let positionLine = []\r\n  if (aPosition.rank == buildNonNulPositionsLine(aPosition.line, aMatrix)[buildNonNulPositionsLine(aPosition.line, aMatrix).length - 1].rank) {\r\n    positionLine = [...positionLine, aPosition]\r\n  }\r\n  else {\r\n    positionLine = aPath.filter(e => e.line == aPosition.line && e.rank != buildNonNulPositionsLine(aPosition.line, aMatrix)[buildNonNulPositionsLine(aPosition.line, aMatrix).length - 1].rank)\r\n  }     //console.log(\"position\",aPosition, \"posiLi\",positionLine)\r\n  return positionLine\r\n}\r\n\r\n\r\nexport function advanceAselectPosition(anObjectOfCurrentPosition, aMatrix) {\r\n\r\n  let thisPosition = extractPositionFromId(anObjectOfCurrentPosition.anElementId)\r\n  let linePositions = buildNonNulPositionsLine(anObjectOfCurrentPosition.listOfPath[0].line, aMatrix)\r\n  let firstPosition = linePosition(anObjectOfCurrentPosition.listOfPath, anObjectOfCurrentPosition.listOfPath[0], aMatrix).filter(e => !_.isEqual(e, thisPosition)).length == 0 ?\r\n    [linePositions[linePositions.length - 1]] : linePosition(anObjectOfCurrentPosition.listOfPath, anObjectOfCurrentPosition.listOfPath[0], aMatrix).filter(e => !_.isEqual(e, thisPosition))\r\n\r\n  if (_.isEqual(anObjectOfCurrentPosition.aCurrentPosition[anObjectOfCurrentPosition.aCurrentPosition.length - 1], anObjectOfCurrentPosition.listOfPath[anObjectOfCurrentPosition.listOfPath.length - 1])) {\r\n    anObjectOfCurrentPosition.aCurrentPosition = firstPosition\r\n  }\r\n  else {\r\n    let anextPosition = anObjectOfCurrentPosition.listOfPath.find(e => (e.line > anObjectOfCurrentPosition.aCurrentPosition[0].line || (e.line == anObjectOfCurrentPosition.aCurrentPosition[0].line && e.rank > anObjectOfCurrentPosition.aCurrentPosition[0].rank)) && !anObjectOfCurrentPosition.aCurrentPosition.some(x => _.isEqual(x, e)))\r\n    let nextPositions = linePosition(anObjectOfCurrentPosition.listOfPath, anextPosition, aMatrix).filter(e => !_.isEqual(e, thisPosition))\r\n    if (nextPositions.length > 0) {\r\n      anObjectOfCurrentPosition.aCurrentPosition = nextPositions\r\n    }\r\n    else {\r\n      let followingPosition = anObjectOfCurrentPosition.listOfPath.find(e => (e.line > thisPosition.line || (e.line == thisPosition.line && e.rank > thisPosition.rank)) && !linePosition(anObjectOfCurrentPosition.listOfPath, thisPosition, aMatrix).some(x => _.isEqual(x, e)))\r\n      if (followingPosition) {\r\n        anObjectOfCurrentPosition.aCurrentPosition = linePosition(anObjectOfCurrentPosition.listOfPath, followingPosition, aMatrix)\r\n      }\r\n      else {\r\n        anObjectOfCurrentPosition.aCurrentPosition = firstPosition\r\n      }\r\n    }\r\n  }\r\n  return anObjectOfCurrentPosition\r\n}\r\n\r\n\r\nexport function advanceAselectPositionFoward(anObjectOfCurrentPosition, aMatrix) {\r\n\r\n  let thisPosition = extractPositionFromId(anObjectOfCurrentPosition.anElementId)\r\n  let linePositions = buildNonNulPositionsLine(anObjectOfCurrentPosition.listOfPathDown[0].line, aMatrix)\r\n  let firstPosition = linePosition(anObjectOfCurrentPosition.listOfPathDown, anObjectOfCurrentPosition.listOfPathDown[0], aMatrix).filter(e => !_.isEqual(e, thisPosition)).length == 0 ?\r\n    [linePositions[linePositions.length - 1]] : linePosition(anObjectOfCurrentPosition.listOfPathDown, anObjectOfCurrentPosition.listOfPathDown[0], aMatrix).filter(e => !_.isEqual(e, thisPosition))\r\n\r\n  if (_.isEqual(anObjectOfCurrentPosition.aCurrentPositionDown[anObjectOfCurrentPosition.aCurrentPositionDown.length - 1], anObjectOfCurrentPosition.listOfPathDown[anObjectOfCurrentPosition.listOfPathDown.length - 1])) {\r\n    anObjectOfCurrentPosition.aCurrentPositionDown = firstPosition\r\n  }\r\n  else {\r\n    let anextPosition = anObjectOfCurrentPosition.listOfPathDown.find(e => (e.line > anObjectOfCurrentPosition.aCurrentPositionDown[0].line || (e.line == anObjectOfCurrentPosition.aCurrentPositionDown[0].line && e.rank > anObjectOfCurrentPosition.aCurrentPositionDown[0].rank)) && !anObjectOfCurrentPosition.aCurrentPositionDown.some(x => _.isEqual(x, e)))\r\n    let nextPositions = linePosition(anObjectOfCurrentPosition.listOfPathDown, anextPosition, aMatrix).filter(e => !_.isEqual(e, thisPosition))\r\n    if (nextPositions.length > 0) {\r\n      anObjectOfCurrentPosition.aCurrentPositionDown = nextPositions\r\n    }\r\n    else {\r\n      let followingPosition = anObjectOfCurrentPosition.listOfPathDown.find(e => (e.line > thisPosition.line || (e.line == thisPosition.line && e.rank > thisPosition.rank)) && !linePosition(anObjectOfCurrentPosition.listOfPathDown, thisPosition, aMatrix).some(x => _.isEqual(x, e)))\r\n      if (followingPosition) {\r\n        anObjectOfCurrentPosition.aCurrentPositionDown = linePosition(anObjectOfCurrentPosition.listOfPathDown, followingPosition, aMatrix)\r\n      }\r\n      else {\r\n        anObjectOfCurrentPosition.aCurrentPositionDown = firstPosition\r\n      }\r\n    }\r\n  }\r\n  return anObjectOfCurrentPosition\r\n}\r\n\r\nexport function advanceSelectPositionsFoward(anArrayOfCurrentPositions, aMatrix) {//aListOfCurrentPosition={aPosition:..., anElementId:...idPosition:, listhOfPath:} anElementId is an id corresponding to aPosition\r\n  return anArrayOfCurrentPositions.map(e => advanceAselectPositionFoward(e, aMatrix))\r\n}\r\n\r\nexport function advanceSelectPositions(anArrayOfCurrentPositions, aMatrix) {//aListOfCurrentPosition={aPosition:..., anElementId:...idPosition:, listhOfPath:} anElementId is an id corresponding to aPosition\r\n  return anArrayOfCurrentPositions.map(e => advanceAselectPosition(e, aMatrix))\r\n}\r\n\r\nexport function compare(a, b) {\r\n  if (a.line == b.line) {\r\n    if (a.rank < b.rank) {\r\n      return -1\r\n    }\r\n    else {\r\n      if (a.rank > b.rank) {\r\n        return 1\r\n      }\r\n      else {\r\n        return 0\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    if (a.line < b.line) {\r\n      return -1\r\n    }\r\n    else {\r\n      return 1\r\n    }\r\n  }\r\n}\r\n\r\nexport function computeSuffix(aPosition, anArrayOfCurrentPositions) {\r\n  let suffix = null\r\n  if (anArrayOfCurrentPositions) {\r\n    if (anArrayOfCurrentPositions.find(e => _.isEqual(extractPositionFromId(e.anElementId), aPosition))) {\r\n      suffix = \"id\" + anArrayOfCurrentPositions.find(e => _.isEqual(extractPositionFromId(e.anElementId), aPosition)).idPosition\r\n    }\r\n    else {\r\n      if (anArrayOfCurrentPositions.find(e => e.aCurrentPosition.find(x => _.isEqual(x, aPosition)))) {\r\n        suffix = \"el\" + anArrayOfCurrentPositions.find(e => e.aCurrentPosition.find(x => _.isEqual(x, aPosition))).idPosition\r\n      }\r\n      else {\r\n        suffix = \"\"\r\n      }\r\n    }//console.log(\"suffix\",suffix,\"aPosition\",aPosition,\"aListOfcurrent\", anArrayOfCurrentPositions)\r\n  }\r\n  return suffix\r\n}\r\n\r\nexport function findPositionInCurrentPositions(indexLine, aListOfCurrentPosition) {\r\n  return aListOfCurrentPosition.find(e => e.aPosition.line == indexLine || extractPositionFromId(e.anElementId).line == indexLine) ?\r\n    (aListOfCurrentPosition.find(e => e.aPosition.line == indexLine) ? aListOfCurrentPosition.find(e => e.aPosition.line == indexLine).aPosition :\r\n      extractPositionFromId(aListOfCurrentPosition.find(e => extractPositionFromId(e.anElementId).line == indexLine).anElementId)) : null\r\n}\r\n\r\nexport function matrixToPosition(aMatrix) {// build a matrix of position with a given matrix\r\n  let matrixPosition = aMatrix.map((e, i) => i == 0 ? e : e.map((x, j) => j == 0 ? x : (buildPosition(i, j, aMatrix) ? (buildPosition(i, j, aMatrix).length == 1 ?\r\n    (_.isEqual(buildPosition(i, j, aMatrix)[0], buildNonNulPositionsLine(i, aMatrix)[buildNonNulPositionsLine(i, aMatrix).length - 1]) ? Array.of(Array.of(), Array.of(), Array.of(buildPosition(i, j, aMatrix)[0])) :\r\n      Array.of(Array.of(buildPosition(i, j, aMatrix)[0]), Array.of(), Array.of())) :\r\n    Array.of(Array.of(buildPosition(i, j, aMatrix)[0]), Array.of(), Array.of(buildPosition(i, j, aMatrix)[1]))) :\r\n    Array.of(Array.of(), Array.of(), Array.of()))))\r\n  return matrixPosition\r\n}\r\n\r\n\r\n\r\nexport function emptyPositionsAndCoordinateOfFigures(aMatrixPosition, aMatrixCoordinate) {// build a matrix of figures (svg elements) with a given matrix of positions and a matrix of coordinates (with empty classNames)\r\n  let emptyMatrixFigures = aMatrixPosition.map((e, i) => i == 0 ? e.map((x, j) => j == 0 ? (<g transform={'translate(' + aMatrixCoordinate[i][j][0] + ',' + aMatrixCoordinate[i][j][1] + ')'}><rect className=\"name\" x=\"0\" y=\"0\" width={\"\" + aMatrixCoordinate[i][j][2]} height={\"\" + aMatrixCoordinate[i][j][3]}></rect>\r\n    <text className=\"textname\" alignmentBaseline=\"middle\" textAnchor=\"middle\" x={\"\" + aMatrixCoordinate[i][j][2] / 2} y={\"\" + aMatrixCoordinate[i][j][3] / 2}>{x}</text></g>) :\r\n    (<g transform={'translate(' + aMatrixCoordinate[i][j][0] + ',' + aMatrixCoordinate[i][j][1] + ')'}><rect className=\"head\" x=\"0\" y=\"0\" width={\"\" + aMatrixCoordinate[i][j][2]} height={\"\" + aMatrixCoordinate[i][j][3]}></rect>\r\n      <text className=\"texthead\" alignmentBaseline=\"middle\" textAnchor=\"middle\" x={\"\" + aMatrixCoordinate[i][j][2] / 2} y={\"\" + aMatrixCoordinate[i][j][3] / 2}>{x}</text></g>)) :\r\n    e.map((x, j) => j == 0 ? (<g transform={'translate(' + aMatrixCoordinate[i][j][0] + ',' + aMatrixCoordinate[i][j][1] + ')'}><rect className=\"emptyIntrinsicName\" x=\"0\" y=\"0\" width={\"\" + aMatrixCoordinate[i][j][2]} height={\"\" + aMatrixCoordinate[i][j][3]}></rect>\r\n      <text className=\"emptyTextintrinsicName\" alignmentBaseline=\"middle\" textAnchor=\"middle\" x={\"\" + aMatrixCoordinate[i][j][2] / 2} y={\"\" + aMatrixCoordinate[i][j][3] / 2}></text></g>) :\r\n      x.map((t, l) => t.length == 0 ? (<g transform={'translate(' + aMatrixCoordinate[i][j][l][0] + ',' + aMatrixCoordinate[i][j][l][1] + ')'}><rect className=\"empty\" x=\"0\" y=\"0\" width={\"\" + aMatrixCoordinate[i][j][l][2]} height={\"\" + aMatrixCoordinate[i][j][l][3]}></rect></g>) :\r\n        (l == 0 ? (<g transform={'translate(' + aMatrixCoordinate[i][j][l][0] + ',' + aMatrixCoordinate[i][j][l][1] + ')'}><rect className=\"empty\" x=\"0\" y=\"0\" width={\"\" + aMatrixCoordinate[i][j][l][2]} height={\"\" + aMatrixCoordinate[i][j][l][3]}></rect></g>) :\r\n          (<g transform={'translate(' + aMatrixCoordinate[i][j][l][0] + ',' + aMatrixCoordinate[i][j][l][1] + ')'}><rect className=\"empty\" x=\"0\" y=\"0\" width={\"\" + aMatrixCoordinate[i][j][l][2]} height={\"\" + aMatrixCoordinate[i][j][l][3]}></rect></g>)))))\r\n  return emptyMatrixFigures\r\n}\r\n\r\nexport function matrixToCoordinate(aMatrx, anOrigin, widthOfFigures, heightOfFigures) {//build a matrix of coordinates with a given matrix, origin, width and height of figures\r\n  let matrixCoordinate = aMatrx.map((e, i) => i == 0 ? e.map((x, j) => Array.of(anOrigin + j * widthOfFigures, anOrigin + i * heightOfFigures, widthOfFigures, heightOfFigures)) :\r\n    e.map((x, j) => j == 0 ? Array.of(anOrigin + j * widthOfFigures, anOrigin + i * heightOfFigures, widthOfFigures, heightOfFigures) :\r\n      Array.of(Array.of(anOrigin + j * widthOfFigures, anOrigin + i * heightOfFigures, widthOfFigures, heightOfFigures / 3),\r\n        Array.of(anOrigin + j * widthOfFigures, anOrigin + (3 * i + 1) * heightOfFigures / 3, widthOfFigures, heightOfFigures / 3),\r\n        Array.of(anOrigin + j * widthOfFigures, anOrigin + (3 * i + 2) * heightOfFigures / 3, widthOfFigures, heightOfFigures / 3))))\r\n  return matrixCoordinate\r\n}\r\n\r\n\r\nexport function removeDuplicatesFromArray(anArray) {\r\n  return [...new Set(anArray.map(o => JSON.stringify(o)))].map(s => JSON.parse(s))\r\n}\r\n\r\nexport function removeDuplicatesEltsFromArray(anArray) {\r\n  return anArray.reduce((acc, e) => !acc.find(x => x.props.id == e.props.id) ? [e, ...acc] : acc, [])\r\n}\r\n\r\nexport function constructPositionFromId(anIdOfFirstColumnPosition) {\r\n  let myArray = /(\\d+)name\\S*line(\\d+)/g.exec(anIdOfFirstColumnPosition)\r\n  let line = parseInt(myArray[1], 10)\r\n  let codeLine = parseInt(myArray[2], 10)\r\n  return { line: line, column: 0, rank: 0, codeLine: codeLine }\r\n}\r\n\r\nexport function constructDescription(aSimdFunction, aDescriptionFile, returnType) {// take a name of a function (which return returnType) and construct a look-like manufacturer description using a file provide by the manufacturer (Intel)\r\n  var objectDescription;\r\n  if (returnType) {\r\n    objectDescription = aDescriptionFile.intrinsic.find(o => (o._name.toLocaleLowerCase() == aSimdFunction.toLocaleLowerCase()) && (returnType.toLocaleLowerCase() == o._rettype.toLocaleLowerCase()));\r\n  }\r\n  else {\r\n    objectDescription = aDescriptionFile.intrinsic.find(o => o._name.toLocaleLowerCase() == aSimdFunction.toLocaleLowerCase());\r\n  }\r\n  let parameter = !objectDescription.hasOwnProperty(\"parameter\") ? \"void\" : objectDescription.parameter;\r\n  objectDescription = { ...objectDescription, parameter }//we add parameter property if it doesn't yet exist\r\n  let line1 = `${objectDescription._rettype} ${objectDescription._name} (${Array.isArray(objectDescription.parameter) ? objectDescription.parameter.flatMap((e, i) => i < objectDescription.parameter.length - 1 ? [e._type, e._varname + \",\"] : [e._type, e._varname]).join(\" \") : objectDescription.parameter})`;\r\n  let line2 = `Synopsis \\n\\t\\t${line1} \\n\\t\\t#include <${objectDescription.header}>\\n\\t\\tInstruction: ${objectDescription.hasOwnProperty(\"instruction\") ? objectDescription.instruction[0]._name + \" \" + objectDescription.instruction[0]._form : \"sequence\"}\\n\\t\\t${objectDescription.hasOwnProperty(\"CPUID\") ? \"CPUID Flags: \" + objectDescription.CPUID : \"\"} `;\r\n  let line3 = `Description \\n\\t\\t${objectDescription.description}`;\r\n  let line4 = `Operation \\n\\t\\t${objectDescription.operation.replaceAll('\\t', '\\t\\t').replaceAll('\\n', '\\n\\t\\t')}`;\r\n  return [objectDescription, `${line1}\\n\\n\\t${line2}\\n\\n\\t${line3}\\n\\n\\t${line4}`];\r\n}\r\n\r\nexport function constructDataListTable(aSimdDescriptionFile) {// take a file provide the manufacturer (like Intel) where simd instructions are describe and return a table with the name of simd instructions on others featurest\r\n  return aSimdDescriptionFile.intrinsic.map(e => {\r\n    let parameter = !e.hasOwnProperty(\"parameter\") ? \"void\" : e.parameter;\r\n    let objectDescription = e;\r\n    objectDescription = { ...objectDescription, parameter }//we add parameter property if it doesn't yet exist\r\n    let line1 = `${objectDescription._rettype} ${objectDescription._name} (${Array.isArray(objectDescription.parameter) ? objectDescription.parameter.flatMap((e, i) => i < objectDescription.parameter.length - 1 ? [e._type, e._varname + \",\"] : [e._type, e._varname]).join(\" \") : objectDescription.parameter})`;\r\n    let line2 = `Synopsis \\n\\t\\t${line1} \\n\\t\\t#include <${objectDescription.header}>\\n\\t\\tInstruction: ${objectDescription.hasOwnProperty(\"instruction\") ? objectDescription.instruction[0]._name + \" \" + objectDescription.instruction[0]._form : \"sequence\"}\\n\\t\\t${objectDescription.hasOwnProperty(\"CPUID\") ? \"CPUID Flags: \" + objectDescription.CPUID : \"\"} `;\r\n    let line3 = `Description \\n\\t\\t${objectDescription.description}`;\r\n    let line4 = typeof (objectDescription.operation) === \"string\" ? `Operation \\n\\t\\t${objectDescription.operation.replaceAll('\\t', '\\t\\t').replaceAll('\\n', '\\n\\t\\t')}` : `Operation \\n\\t\\t No operation`;\r\n    return [objectDescription._name, objectDescription._rettype, objectDescription.parameter, `${line1}\\n\\n\\t${line2}\\n\\n\\t${line3}\\n\\n\\t${line4}`]\r\n  });\r\n}\r\n\r\nexport function computeOperandsAndresultElt(aSimdDescriptionFile) {// take a file provide the manufacturer (like Intel) where simd instructions are describe and return and array of objects {name:\"nameOfIntrinsicInstruction\", retype:\"returnType\",operands:[], result: [], varnames:[], types:[], sizeOfScalarFiel:0} desscribing each instruction\r\n  return aSimdDescriptionFile.intrinsic.map(e => {\r\n    var obj = {};\r\n    let name = e._name;\r\n    obj = { ...obj, name };\r\n    var regTypeNumber = /(?<=_m|__m|_int|__int)\\d+/g;\r\n    var regextractSizeFromDesc = /\\d+(?=-bit)/g;// We have notice that the size of scalar unit of a vector instruction can be assimilated to a x-bit expression in the description of tha instruction\r\n    let arrayOfMinimunSizeInDescription = e.description.match(regextractSizeFromDesc);\r\n    const sizeOfScalarField = arrayOfMinimunSizeInDescription ? Math.min(...arrayOfMinimunSizeInDescription) : 1;\r\n    var maxSize = sizeOfScalarField;\r\n    obj = { ...obj, sizeOfScalarField };\r\n    var result = [];\r\n    if (e._rettype) {\r\n      let retType = e._rettype;\r\n      obj = { ...obj, retType };\r\n      let retTypeNumber = e._rettype.match(regTypeNumber);\r\n      retTypeNumber = retTypeNumber ? retTypeNumber[0] : 0;\r\n      maxSize = retTypeNumber > maxSize ? retTypeNumber : maxSize;\r\n      if (retTypeNumber != 0) {\r\n        let size = retTypeNumber / sizeOfScalarField;\r\n        for (let i = 0; i < size; i++) {\r\n          result = [...result, i]\r\n        }\r\n      }\r\n      obj = { ...obj, result };\r\n    }\r\n    var operands = [], varnames = [], types = [];\r\n    if (e.parameter && Array.isArray(e.parameter)) {\r\n      e.parameter.forEach((element, k) => {\r\n        if (element._type) {\r\n          types[k] = element._type.split(\" \")[element._type.split(\" \").length - 1];\r\n          varnames[k] = element._varname;\r\n          obj = { ...obj, varnames, types };\r\n          let operandNumber = types[k].match(regTypeNumber);\r\n          var operand = [];\r\n          if (operandNumber) {\r\n            let operandSize = operandNumber[0];\r\n            maxSize = operandSize > maxSize ? operandSize : maxSize;\r\n            let size = operandSize / sizeOfScalarField;\r\n            for (let i = 0; i < size; i++) {\r\n              operand = [...operand, i]\r\n            }\r\n            operands = [...operands, operand];\r\n            obj = { ...obj, operands };\r\n          }\r\n          else {\r\n            let fieldArray = types[k].match(/(?<=_m|__m|_int|__int)\\w*mask\\w*/g);\r\n            let operandSize = (fieldArray || element._varname == \"imm8\") ? maxSize : sizeOfScalarField;\r\n            let size = operandSize / sizeOfScalarField;\r\n            for (let i = 0; i < size; i++) {\r\n              operand = [...operand, i];\r\n            }\r\n            operands = [...operands, operand];\r\n            obj = { ...obj, operands };\r\n          }\r\n        }\r\n      });\r\n    }\r\n    if (result.length == 0 && e._rettype.match(/(?<=_m|__m|_int|__int)\\w*mask\\w*/g)) {\r\n      let size = maxSize / sizeOfScalarField;\r\n      for (let i = 0; i < size; i++) {\r\n        result = [...result, i]\r\n      }\r\n      obj = { ...obj, result };\r\n    }\r\n    return obj;\r\n  })\r\n}\r\n\r\n\r\nexport function buildMessage(operators, operands) {\r\n  const globalTab = (Array.isArray(operands) && Array.isArray(operators)) ?\r\n    [...operands, ...operators] : (Array.isArray(operators) ?\r\n      operands : (Array.isArray(operators) ? operators : []));\r\n  var message = globalTab.sort((o1, o2) => o1.rank - o2.rank).map(o => {\r\n    if (o.hasOwnProperty(\"idOperand\")) {\r\n\r\n      return document.getElementById(o.idOperand).textContent;\r\n    }\r\n    else if (o.hasOwnProperty(\"idOperator\")) {\r\n      return document.getElementById(o.idOperator).textContent;\r\n    }\r\n\r\n    else {\r\n      return \"\";\r\n    }\r\n  }).join('');\r\n  return message\r\n}\r\nexport function readLinkingIndexMsg(aLinkingIndex) {//take a linking index and return a message\r\n  var Msge = \"Click on a result field to see its calculation explained\";\r\n  let indexOfactive = aLinkingIndex.findIndex(e => e[0] == \"active\");\r\n  Msge = indexOfactive == -1 ? Msge : aLinkingIndex[indexOfactive].slice(1).flat().sort((a, b) => a[1] - b[1]).reduce((pre, cur) => cur[2] ? [...pre, cur[2], cur[0]] : [...pre, cur[0]], []).join(\" \")\r\n  return Msge\r\n  // const globalTab = (Array.isArray(operands) && Array.isArray(operators)) ?\r\n  //   [...operands, ...operators] : (Array.isArray(operators) ?\r\n  //     operands : (Array.isArray(operators) ? operators : []));\r\n  // var message = globalTab.sort((o1, o2) => o1.rank - o2.rank).map(o => {\r\n  //   if (o.hasOwnProperty(\"idOperand\")) {\r\n\r\n  //     return document.getElementById(o.idOperand).textContent;\r\n  //   }\r\n  //   else if (o.hasOwnProperty(\"idOperator\")) {\r\n  //     return document.getElementById(o.idOperator).textContent;\r\n  //   }\r\n\r\n  //   else {\r\n  //     return \"\";\r\n  //   }\r\n  // }).join('');\r\n  // return message\r\n}\r\n","import React, { Component } from 'react';\r\nimport * as myLib from '../utilities/myLibrary.js';\r\nimport '../styles/CodeText.css';\r\nimport simdFunction from '../utilities/simdFunction.json';\r\n\r\nconst myDataListTab = myLib.constructDataListTable(simdFunction);\r\nconst options=myDataListTab.map((e, i) => <option key={`${e[0]}-${i}`} value={e[0]}></option>)\r\n\r\nconst returnTypeAndParam = simdFunction.intrinsic.reduce((acc, cur) => {\r\n    if (cur._rettype) {\r\n        acc = acc.indexOf(cur._rettype) == -1 ? [...acc, cur._rettype] : [...acc];\r\n    }\r\n    if (cur.parameter && Array.isArray(cur.parameter)) {\r\n        cur.parameter.forEach(element => {\r\n            if (element._type) {\r\n                acc = acc.indexOf(element._type) == -1 ? [...acc, element._type] : [...acc];\r\n            }\r\n            return acc\r\n        });\r\n\r\n    }\r\n    return acc\r\n}, []);\r\nconst operandsAndResults = myLib.computeOperandsAndresultElt(simdFunction);\r\nconst _mName = simdFunction.intrinsic.find((e, i) => {\r\n    var ex = \"\"\r\n    if (e._rettype) {\r\n        ex = e._rettype == \"_m512\" ? e._rettype : ex;\r\n    }\r\n    if (e.parameter && Array.isArray(e.parameter)) {\r\n        e.parameter.forEach(element => {\r\n            if (element._type) {\r\n                ex = element._type == \"_m512\" ? element._type : ex;\r\n            }\r\n        });\r\n\r\n    }\r\n    if (ex) return e;\r\n    return ex;\r\n});\r\nclass CodeText extends Component {\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props) {\r\n        super(props);\r\n\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n    }\r\n\r\n    componentDidUpdate() {\r\n\r\n    }\r\n\r\n    componentWillUnmount() {\r\n\r\n    }\r\n\r\n    render() {\r\n     \r\n        var  handleOnchange = this.props.handleOnchange, value = this.props.value;\r\n        const description = myDataListTab.find(e => e[0] == value)[3];\r\n        return (\r\n\r\n            <div className='instruction-choice-and-explanation'>\r\n\r\n                <label htmlFor=\"instruction-name-search\"><span className=\"button\">Choose SIMD Instruction</span></label><br />\r\n                <input type=\"search\" id=\"instruction-name-search\" name=\"instruction-name-search\" autoComplete=\"on\"\r\n                    aria-label=\"Search the name of simd instruction\" list=\"myDataListTab\" defaultValue={value}\r\n                    onChange={(e) => handleOnchange(e)}></input>\r\n                <datalist id=\"myDataListTab\">\r\n                    {options}\r\n                </datalist>\r\n                <div className=\"plain-text-explanation\">\r\n                    {description}\r\n                </div>\r\n\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default CodeText","export default __webpack_public_path__ + \"static/media/logo.0333e8cd.png\";","import React, { Component } from 'react';\r\nimport * as myLib from '../utilities/myLibrary.js';\r\nimport '../styles/Operand.css';\r\nimport * as _ from \"lodash\";\r\nimport simdFunction from '../utilities/simdFunction.json';\r\n\r\nclass Operand extends Component {\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props) {\r\n        super(props);\r\n\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n    }\r\n\r\n    componentDidUpdate(prevProps, prevState, snapshot) {\r\n\r\n    }\r\n\r\n    componentWillUnmount() {\r\n\r\n    }\r\n\r\n\r\n    render() {\r\n        var result = this.props.operand.reduce((accumulator, currentValue) => [currentValue, ...accumulator], []);\r\n        var rank = this.props.rank, type = this.props.type;\r\n        const rectOprHeight = 50, rectOprWidth = 80, spaceOprBetween = 10, xOpr0 = \"0\", yOpr0 = \"0\";\r\n        const rectOperandHeight = 20, rectOperandWidth = 20, spaceBetweenOperand = 0.5, xOperand0 = this.props.xPrefixWidth, yOperand0 = \"0\";\r\n        const gOperand = result.map((o, j) => <g key={(type.toLowerCase() + rank) + o} id={(type.toLowerCase() + rank) + o} className={(type.toLowerCase() + rank) + o} onClick={evt => this.props.handleOperandClick(evt)}>\r\n            <rect key={\"recScalar\" + type + (rank + j)} id={\"recScalar\" + type + (rank + j)} className={\"recScalar\" + type + (rank + j)} y={yOperand0 + (rank * (rectOperandHeight + spaceOprBetween))} x={xOperand0 + (j * (rectOperandWidth + spaceBetweenOperand))} width={\"\" + rectOperandWidth}\r\n                height={\"\" + rectOperandHeight}></rect>\r\n            <text key={\"txtScalar\" + type + (rank + j)} id={\"txtScalar\" + type + (rank + j)} className={\"txtScalar\" + type + (rank + j)} dy=\"0 2%\" y={yOperand0 + (rank * spaceOprBetween + (2 * rank + 1) * rectOperandHeight / 2)} dx=\"0 0.07%\" x={xOperand0 +\r\n                (j * (rectOperandWidth + spaceBetweenOperand) + (rectOperandHeight / 2))} dominantBaseline=\"middle\" textAnchor=\"middle\">{String.fromCharCode(65 + rank)}{o}</text>\r\n            </g>)\r\n        return (\r\n            <>\r\n                {gOperand}\r\n                <text key={\"prefixScalar\" + type + rank} id={\"prefixScalar\" + type + rank} className={\"prefixScalar\" + type + rank} y={yOperand0 + (rank * spaceOprBetween + (2 * rank + 1) * rectOperandHeight / 2)} x={this.props.xPrefixWidth / 2} dominantBaseline=\"middle\" textAnchor=\"middle\">{`${this.props.varName}   ${this.props.varType}`}</text>\r\n            </>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Operand","import React, { Component } from 'react';\r\nimport * as myLib from '../utilities/myLibrary.js';\r\nimport '../styles/Operands.css';\r\nimport simdFunction from '../utilities/simdFunction.json';\r\nimport Operand from './Operand';\r\n\r\n\r\nclass Operands extends Component {\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props) {\r\n        super(props);\r\n\r\n    }\r\n\r\n    componentDidMount() {;\r\n\r\n    }\r\n\r\n    componentDidUpdate() {\r\n\r\n    }\r\n\r\n    componentWillUnmount() {\r\n\r\n    }\r\n  \r\n    render() {\r\n        const currentInstruction = this.props.currentInstruction, xPrefixWidth=this.props.xPrefixWidth;\r\n        const currentInstructionMember = [...currentInstruction.operands, currentInstruction.result]\r\n        const operands = currentInstructionMember.map((e, i) =>(currentInstructionMember.length - 1 == i)?\r\n                                     <Operand xPrefixWidth={xPrefixWidth} key={i} operand={e} rank={i} handleOperandClick={this.props.handleOperandClick} type={ \"Result\"} varType={currentInstruction.retType} varName=\"r\"></Operand>:\r\n                                                                    <Operand xPrefixWidth={xPrefixWidth} key={i} operand={e} rank={i} handleOperandClick={this.props.handleOperandClick} type={\"Operand\"} varType={currentInstruction.types[i]} varName={currentInstruction.varnames[i]}></Operand>);\r\n        return (\r\n\r\n            <g id=\"operands\" className=\"operands\" transform={\"translate( 0,\" + this.props.translation + \")\"}>\r\n                {operands}\r\n            </g>\r\n        )\r\n    }\r\n}\r\nexport default Operands","import React, { Component } from 'react';\r\nimport * as myLib from '../utilities/myLibrary.js';\r\nimport '../styles/Operator.css';\r\nimport simdFunction from '../utilities/simdFunction.json';\r\n\r\n\r\nconst operators = ['+', 'x', '-', '/', 'mov', ':(int)', 'exp', 'ln', '(', ')'];\r\n\r\n\r\nclass Operator extends Component {\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props) {\r\n        super(props);\r\n\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n    }\r\n\r\n    componentDidUpdate() {\r\n\r\n    }\r\n\r\n    componentWillUnmount() {\r\n\r\n    }\r\n\r\n\r\n    render() {\r\n\r\n        var rectOprHeight = this.props.rectOprHeight, rectOprWidth = 35, spaceOprBetween = 17, yOpr0 = \"0\", xOpr0 = this.props.xPrefixWidth;\r\n        const gOperator = operators.map((e, i) => <g key={\"operator\" + i} id={\"operator\" + i} className={\"operator\" + i} onClick={evt => this.props.handleOperatorClick(evt)}>\r\n            <rect key={\"rectOperator\" + i} id={\"rectOperator\" + i} className={\"rectOperator\" + i} x={xOpr0 + (i * (rectOprHeight + spaceOprBetween))} y={yOpr0} width={\"\" + rectOprWidth} height={\"\" + rectOprHeight}></rect>\r\n            <text key={\"txtOperator\" + i} id={\"txtOperator\" + i} className={\"txtOperator\" + i} x={xOpr0 + (i * (rectOprHeight + spaceOprBetween))} dx={\"\" + rectOprWidth / 2} y={yOpr0} dy={\"\" + rectOprWidth / 2} dominantBaseline=\"middle\" textAnchor=\"middle\">{e}</text>\r\n            </g>);\r\n\r\n\r\n\r\n        return (\r\n            <>\r\n                {gOperator}\r\n                <text key={\"prefixOperator\"} id={\"prefixOperator\"} className={\"prefixOperator\"} x={xOpr0/2} y={yOpr0} dy={\"\" + rectOprWidth / 2} dominantBaseline=\"middle\" textAnchor=\"middle\">{\"operator\"}</text>\r\n            </>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Operator","import React, { Component } from 'react';\r\nimport * as myLib from '../utilities/myLibrary.js';\r\nimport '../styles/Operations.css';\r\nimport simdFunction from '../utilities/simdFunction.json';\r\nimport Operands from './Operands';\r\nimport Operator from './Operator';\r\n\r\n\r\n\r\nclass Operations extends Component {\r\n    // eslint-disable-next-line no-useless-constructor\r\n    constructor(props) {\r\n        super(props);\r\n\r\n\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n    }\r\n\r\n    componentDidUpdate() {\r\n\r\n    }\r\n\r\n    componentWillUnmount() {\r\n\r\n    }\r\n\r\n\r\n    render() {\r\n        const rectOprHeight = 35, xPrefixWidth=75;\r\n        return (\r\n\r\n        \r\n                <svg id=\"operations\" className=\"operations\" width=\"100%\" height=\"100%\" version=\"1.1\"\r\n                    xmlns=\"http://www.w3.org/2000/svg\" xmlnsXlink=\"http://www.w3.org/1999/xlink\">\r\n                    <Operator xPrefixWidth={xPrefixWidth} rectOprHeight={rectOprHeight} linkingIndex={this.props.linkingIndex} handleOperatorClick={this.props.handleOperatorClick}/>\r\n                    <Operands xPrefixWidth={xPrefixWidth} translation={rectOprHeight + rectOprHeight / 2} currentInstruction={this.props.currentInstruction}\r\n                        linkingIndex={this.props.linkingIndex} handleOperandClick={this.props.handleOperandClick} />\r\n                </svg>\r\n    \r\n        )\r\n    }\r\n}\r\n\r\nexport default Operations","import React, { Component } from 'react';\r\nimport * as myLib from '../utilities/myLibrary.js';\r\nimport '../styles/Explanation.css';\r\nimport simdFunction from '../utilities/simdFunction.json';\r\n\r\n\r\n\r\n\r\nclass Explanation extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.currentResult = null;\r\n        this.butonMsg = null;\r\n\r\n\r\n\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n    }\r\n\r\n    componentDidUpdate(prevProps, prevState) {\r\n        if (this.props.value !== prevProps.value) {\r\n            this.currentResult = this.props.currentResult\r\n            this.butonMsg = myLib.readLinkingIndexMsg(this.props.linkingIndex);\r\n        }\r\n\r\n    }\r\n\r\n    componentWillUnmount() {\r\n\r\n    }\r\n\r\n\r\n    render() {\r\n        this.butonMsg = myLib.readLinkingIndexMsg(this.props.linkingIndex);\r\n        this.currentResult = this.props.currentResult;\r\n\r\n        \r\n        return (\r\n\r\n\r\n            <div id=\"explanation\" className=\"explanation\">\r\n                <form id=\"explanationForm\" className=\"explanationForm\">\r\n                    <p id=\"outputParagraph\" className=\"outputParagraph\">\r\n                        <label>{this.currentResult && `How to compute the field  `}</label>\r\n                        <output id=\"simdOutput\" className=\"simdOutput\" name=\"outputSimd\" form=\"explanationForm\" >\r\n                            <span id=\"fieldFormul\" className=\"fieldFormul\">{this.currentResult && `${this.currentResult}:  `}</span><span id=\"textFormul\" className=\"textFmormul\">{this.currentResult && `${this.currentResult} =`}{`${this.butonMsg}`}</span>\r\n                        </output>\r\n                    </p>\r\n                    <p id=\"buttonParagraph\" className=\"buttonParagraph\">\r\n                        {this.currentResult && <button id=\"simdButton\" className=\"simdButton\" form=\"explanationForm\" type=\"button\" onClick={evt => this.props.handlesimdButtonClick(evt)}>\r\n                            {`Reset the field ${this.currentResult}  `}\r\n                        </button>}\r\n                    </p>\r\n                </form>\r\n            </div>\r\n\r\n\r\n\r\n\r\n        )\r\n    }\r\n}\r\n\r\nexport default Explanation","import React, { Component } from 'react';\r\nimport * as myLib from '../utilities/myLibrary.js';\r\nimport '../styles/Visualization.css';\r\nimport simdFunction from '../utilities/simdFunction.json';\r\nimport Operations from './Operations';\r\nimport Explanation from './Explanation';\r\n\r\n\r\nconst operandsAndResults = myLib.computeOperandsAndresultElt(simdFunction);\r\nconst constInitialLinkingIndexInstruction = (instructionName) => {\r\n    let operand = operandsAndResults.find(e => e.name == instructionName);\r\n    return operand.result.map(o => [\"inactive\", ...operand.operands.map(e => [])])\r\n}\r\n\r\n\r\nclass Visualization extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = { linkingIndex: constInitialLinkingIndexInstruction(props.value), currentOperator: null, currentResult: null };\r\n        this.handleOperandClick = this.handleOperandClick.bind(this);\r\n        this.currentInstruction = operandsAndResults.find(e => e.name == props.value);\r\n        this.linkingIndexTable=[]\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n    }\r\n\r\n    componentDidUpdate(prevProps, prevState, snapshot) {\r\n        if (this.props.value !== prevProps.value) {\r\n            this.currentInstruction = operandsAndResults.find(e => e.name == this.props.value);\r\n            let newLinkinIndexObject={name:prevProps.value, linkingIndex:this.state.linkingIndex }\r\n            let indexOfPrevLinkingIndex=this.linkingIndexTable.findIndex(e=>e.name==prevProps.value)\r\n            this.linkingIndexTable=indexOfPrevLinkingIndex==-1?[...this.linkingIndexTable,newLinkinIndexObject]:this.linkingIndexTable.fill(indexOfPrevLinkingIndex,newLinkinIndexObject,indexOfPrevLinkingIndex+1);\r\n            let linkingIndex=this.linkingIndexTable.find(e=>e.name==this.props.value)?this.linkingIndexTable.find(e=>e.name==this.props.value).linkingIndex:constInitialLinkingIndexInstruction(this.props.value);\r\n            linkingIndex=linkingIndex.map(e=>e.fill(\"inactive\",0,1))\r\n            this.setState(prevState => ({\r\n                linkingIndex: linkingIndex,\r\n                currentOperator: null, \r\n                currentResult: null\r\n            }));\r\n        }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n\r\n    }\r\n    handleOperandClick = (evt) => {//To handle both operand and result clickS\r\n        var currentInstructionR = this.currentInstruction.result.reduce((accumulator, currentValue) => [currentValue, ...accumulator], []);//just to reverse\r\n        if (evt.currentTarget.id.includes(\"result\")) {//result has been clicked\r\n            let number = evt.currentTarget.textContent;\r\n            let indexR = currentInstructionR.findIndex(e => (String.fromCharCode(65 + this.currentInstruction.operands.length) + e) == number);\r\n            var linkingIndex = this.state.linkingIndex;\r\n            linkingIndex = linkingIndex.map((e, i) => i == indexR ? e.map((x, j) => j == 0 ? \"active\" : x) : e.map((x, j) => j == 0 ? \"inactive\" : x));\r\n            this.setState(prevState => ({\r\n                linkingIndex: linkingIndex\r\n            }));\r\n            indexR > -1 && this.setState(prevState => ({\r\n                currentResult: number\r\n            }));\r\n        }\r\n        var currentInstructionO = this.currentInstruction.operands.map(e => e.reduce((accumulator, currentValue) => [currentValue, ...accumulator], []));//just to reverse\r\n        if (evt.currentTarget.id.includes(\"operand\")) {//operand has been clicked\r\n            let number = evt.currentTarget.textContent; \r\n            var indexO = null;\r\n\r\n            let indexOfOperand = currentInstructionO.findIndex((e, i) => {\r\n                indexO = e.indexOf(e.find(o => (String.fromCharCode(65 + i) + o) == number))\r\n                return indexO != -1\r\n            })\r\n            var linkingIndex = this.state.linkingIndex;\r\n            let indexOfResult = linkingIndex.findIndex(e => e[0] == \"active\");\r\n            if (indexOfResult != -1) {\r\n                if (!linkingIndex[indexOfResult].some(e => Array.isArray(e) && e.length != 0)) {\r\n                    linkingIndex[indexOfResult][indexOfOperand + 1] = [[number, 0, this.state.currentOperator], ...linkingIndex[indexOfResult][indexOfOperand + 1]];\r\n                    this.setState(prevState => ({\r\n                        currentOperator: null\r\n                    }));\r\n                }\r\n                else {\r\n                    if (this.state.currentOperator) {\r\n                        const g = (anArray, anIndex) => anArray[anIndex].reduce((acc, ov, id, alik2) => id != 0 && ov.length != 0 ? [...ov.map(x => x[1]), ...acc] : [...acc], [])\r\n                        var indexOfMaxRankArray\r\n                        var maxRank = Math.max(...g(linkingIndex, indexOfResult)) //The current maximun rank of contribution to the current result field\r\n\r\n                        // const operationIdx=(anArray,anIndex)=>anArray[anIndex].findIndex((e, i) => Array.isArray(e) && e.length != 0 && e.findIndex((o, j) => o.indexOf(Math.max(...g(anArray,anIndex))) != -1) != -1)\r\n\r\n                        const operationIdx = (anArray, anIndex) => anArray[anIndex].findIndex((e, i) => {\r\n                            if (Array.isArray(e) && e.length != 0) {\r\n                                indexOfMaxRankArray = e.findIndex((o, j) => o.indexOf(Math.max(...g(anArray, anIndex))) != -1)\r\n                                return indexOfMaxRankArray != -1\r\n                            }\r\n                        })\r\n                        var indexOperand = operationIdx(linkingIndex, indexOfResult);//The index of the operand currently bearing the array of contribution to current result field with the maximun rank\r\n                        linkingIndex[indexOfResult][indexOfOperand + 1] = [[number, maxRank + 1, this.state.currentOperator], ...linkingIndex[indexOfResult][indexOfOperand + 1]];\r\n                        this.setState(prevState => ({\r\n                            currentOperator: null\r\n                        }));\r\n                    }\r\n\r\n\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n    handleOperatorClick = (evt) => {//To handle both Operator clickS\r\n        var linkingIndex = this.state.linkingIndex;\r\n        let indexOfResult = linkingIndex.findIndex(e => e[0] == \"active\");\r\n        let operator = evt.currentTarget.textContent;\r\n        if (indexOfResult != -1) {\r\n            this.setState(prevState => ({\r\n                currentOperator: operator\r\n            }));\r\n        }\r\n    }\r\n\r\n    handlesimdButtonClick = (evt) => {\r\n        let linkingIndex = this.state.linkingIndex;\r\n        linkingIndex.map(e=>e[0]==\"active\"?e.fill([],1):e)\r\n        this.setState(prevState => ({\r\n            linkingIndex: linkingIndex,\r\n            currentOperator: null\r\n        }));\r\n\r\n    }\r\n\r\n    render() {\r\n        \r\n        \r\n        return (\r\n\r\n            <React.Fragment>\r\n                <Explanation value={this.props.value} handlesimdButtonClick={this.handlesimdButtonClick} linkingIndex={this.state.linkingIndex} currentOperator={this.state.currentOperator} currentResult={this.state.currentResult} />\r\n                <Operations value={this.props.value} currentInstruction={this.currentInstruction} linkingIndex={this.state.linkingIndex}\r\n                    handleOperandClick={this.handleOperandClick} handleOperatorClick={this.handleOperatorClick} />\r\n            </React.Fragment>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Visualization","import React, { Component } from 'react';\r\nimport * as myLib from '../utilities/myLibrary.js';\r\nimport simdFunction from '../utilities/simdFunction.json';\r\nimport styled from 'styled-components'\r\nimport logo from '../assets/logo.png';\r\nimport '../styles/App.css';\r\nimport CodeText from './CodeText';\r\nimport Visualization from './Visualization';\r\n\r\nconst Container = styled.div`\r\n  display: flex;\r\n`\r\n\r\nconst LeftContainer = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  height: 100vh\r\n  width: 50vw;\r\n  overflow: auto;\r\n`\r\n\r\nconst RightContainer = styled.div`\r\n  width: 50vw;\r\n  height: 100vh;\r\n  overflow: hidden;\r\n`\r\nconst myDataListTab = myLib.constructDataListTable(simdFunction);\r\n\r\n\r\nclass App extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { value: \"_mm_add_epi8\" };\r\n    this.handleOnchange = this.handleOnchange.bind(this)\r\n  }\r\n\r\n  componentDidMount() {\r\n    \r\n\r\n  }\r\n\r\n  componentDidUpdate() {\r\n\r\n  }\r\n\r\n  componentWillUnmount() {\r\n\r\n  }\r\n  handleOnchange(e) {\r\n    if (myDataListTab.find(o => o[0] == e.target.value)) {\r\n      this.setState(prevState => ({\r\n        value: e.target.value\r\n      }));\r\n    }\r\n\r\n  }\r\n\r\n\r\n\r\n  render() {\r\n    return (\r\n      <div id=\"displayZone\" className=\"displayZone\"><CodeText handleOnchange={this.handleOnchange} value={this.state.value} />\r\n        <Visualization value={this.state.value} />\r\n      </div>\r\n    );\r\n  }\r\n\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read http://bit.ly/CRA-PWA.\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      if (\r\n        response.status === 404 ||\r\n        response.headers.get('content-type').indexOf('javascript') === -1\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './styles/index.css';\r\nimport App from './components/App';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport {HashRouter, Switch, Route} from \"react-router-dom\";\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <HashRouter basename={process.env.PUBLIC_URL}>\r\n      <Switch>\r\n          <Route exact path='/' component={App}/>\r\n          <Route path='/link/:code' component={App}/>\r\n      </Switch>\r\n  </HashRouter>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: http://bit.ly/CRA-PWA\r\nserviceWorker.register();\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}